---
apiVersion: cluster.x-k8s.io/v1beta1
kind: MachineDeployment
metadata:
  name: "${CLUSTER_NAME}-azl3-md-0"
spec:
  clusterName: "${CLUSTER_NAME}"
  replicas: ${AZL3_WORKER_MACHINE_COUNT:=2}
  selector:
    matchLabels:
  template:
    spec:
      clusterName: "${CLUSTER_NAME}"
      version: "${KUBERNETES_VERSION}"
      bootstrap:
        configRef:
          name: "${CLUSTER_NAME}-azl3-md-0"
          apiVersion: bootstrap.cluster.x-k8s.io/v1beta1
          kind: KubeadmConfigTemplate
      infrastructureRef:
        name: "${CLUSTER_NAME}-azl3-md-0"
        apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
        kind: AzureMachineTemplate
---
apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
kind: AzureMachineTemplate
metadata:
  name: "${CLUSTER_NAME}-azl3-md-0"
spec:
  template:
    spec:
      vmSize: ${AZURE_NODE_MACHINE_TYPE}
      osDisk:
        osType: "Linux"
        diskSizeGB: 128
      sshPublicKey: ${AZURE_SSH_PUBLIC_KEY_B64:=""}
      image:
        computeGallery:
          gallery: ClusterAPI-f72ceb4f-5159-4c26-a0fe-2ea738f0d019
          name: capi-azurelinux-3
          version: ${AZL3_VERSION:="1.33.2"}
---
apiVersion: bootstrap.cluster.x-k8s.io/v1beta1
kind: KubeadmConfigTemplate
metadata:
  name: "${CLUSTER_NAME}-azl3-md-0"
spec:
  template:
    spec:
      files:
      - content: |
          #!/bin/bash

          set -o nounset
          set -o pipefail
          set -o errexit

          # Install ca-certificates packages for Azure Linux
          tdnf install -y ca-certificates ca-certificates-legacy
          update-ca-trust

          # Follow Azure Linux 3 docs exactly - completely permissive for debugging
          # Change default policy to ACCEPT (as recommended by AZL3 docs)
          iptables -P INPUT ACCEPT
          iptables -P FORWARD ACCEPT
          iptables -P OUTPUT ACCEPT

          ip6tables -P INPUT ACCEPT
          ip6tables -P FORWARD ACCEPT
          ip6tables -P OUTPUT ACCEPT

          # Flush any rules which would filter packets
          iptables -F
          ip6tables -F

          iptables-save > /etc/systemd/scripts/ip4save
          ip6tables-save > /etc/systemd/scripts/ip6save
        path: /tmp/azl3-setup.sh
        owner: "root:root"
        permissions: "0744"
      - contentFrom:
          secret:
            name: ${CLUSTER_NAME}-azl3-md-0-azure-json
            key: worker-node-azure.json
        owner: root:root
        path: /etc/kubernetes/azure.json
        permissions: "0644"
      - content: |
          #!/bin/bash

          set -o nounset
          set -o pipefail
          set -o errexit

          export KUBEADM_REVISION="${KUBEADM_REVISION:-""}"
          export KUBECTL_REVISION="${KUBECTL_REVISION:-""}"
          export KUBELET_REVISION="${KUBELET_REVISION:-""}"

          BASE_URL="https://kubernetesreleases.blob.core.windows.net/dalec-packages"
          VERSION="${DALEC_KUBERNETES_VERSION}"
          VERSION=$${VERSION#v}
          OS_VERSION="azl3"
          ARCH="x86_64"

          # Check if ANY revision is set - if so, we need to replace ALL binaries
          # to ensure version consistency (kubeadm requires all components to be same version)
          ANY_REVISION_SET="false"
          [[ -n "${KUBEADM_REVISION}" ]] && ANY_REVISION_SET="true"
          [[ -n "${KUBECTL_REVISION}" ]] && ANY_REVISION_SET="true"
          [[ -n "${KUBELET_REVISION}" ]] && ANY_REVISION_SET="true"

          if [[ "$${ANY_REVISION_SET}" != "true" ]]; then
            echo "No *_REVISION variables set. Skipping binary replacement."
            exit 0
          fi

          echo "At least one revision is set. Replacing ALL binaries to ensure version consistency."
          systemctl stop kubelet

          # All binaries that must be replaced for version consistency
          ALL_BINARIES=("kubeadm" "kubectl" "kubelet")

          # Function to find an available revision for a binary (RPM format)
          find_available_revision() {
            local binary="$$1"
            local base_url="$$2"
            local version="$$3"
            local os_version="$$4"
            local arch="$$5"

            # Try revisions from 10 down to 1
            for rev in $(seq 10 -1 1); do
              local rpm_release="$${rev}.$${os_version}"
              local rpm_url="$${base_url}/$${binary}/$${version}/$${os_version}/$${arch}/$${binary}-$${version}-$${rpm_release}.$${arch}.rpm"
              if curl --head --silent --fail "$${rpm_url}" > /dev/null 2>&1; then
                echo "$${rev}"
                return 0
              fi
            done
            return 1
          }

          for BINARY in "$${ALL_BINARIES[@]}"; do
            # Get the revision for this binary (from env var or find available)
            REVISION=""
            case "$${BINARY}" in
              kubeadm) REVISION="${KUBEADM_REVISION}" ;;
              kubectl) REVISION="${KUBECTL_REVISION}" ;;
              kubelet) REVISION="${KUBELET_REVISION}" ;;
            esac

            if [[ -z "$${REVISION}" ]]; then
              echo "* $${BINARY}: no revision specified, finding available revision..."
              REVISION=$(find_available_revision "$${BINARY}" "$${BASE_URL}" "$${VERSION}" "$${OS_VERSION}" "$${ARCH}" || true)
              if [[ -z "$${REVISION}" ]]; then
                echo "ERROR: Could not find any available revision for $${BINARY} version $${VERSION}"
                exit 1
              fi
              echo "* $${BINARY}: found available revision $${REVISION}"
            fi

            RPM_RELEASE="$${REVISION}.$${OS_VERSION}"
            echo "* downloading and extracting binary: $${BINARY} $${VERSION} with rpm release $${RPM_RELEASE}"
            RPM_FILE="/tmp/$${BINARY}-$${VERSION}-$${RPM_RELEASE}.$${ARCH}.rpm"
            RPM_URL="$${BASE_URL}/$${BINARY}/$${VERSION}/$${OS_VERSION}/$${ARCH}/$${BINARY}-$${VERSION}-$${RPM_RELEASE}.$${ARCH}.rpm"

            echo "Downloading from: $${RPM_URL}"
            curl -L --retry 10 --retry-delay 5 "$${RPM_URL}" --output "$${RPM_FILE}"

            echo "Extracting $${BINARY} binary to /usr/bin"
            TEMP_DIR="/tmp/$${BINARY}-extract-$$"
            mkdir -p "$${TEMP_DIR}"
            cd "$${TEMP_DIR}"
            rpm2cpio "$${RPM_FILE}" | cpio -idmv

            if [ -f "./usr/bin/$${BINARY}" ]; then
              mv "./usr/bin/$${BINARY}" "/usr/bin/$${BINARY}"
              chmod +x "/usr/bin/$${BINARY}"
            else
              echo "Error: Binary $${BINARY} not found in RPM package"
              exit 1
            fi

            # Also install config files from the kubelet RPM to replace any
            # stale flags from the gallery image (e.g. --pod-infra-container-image
            # which was removed in v1.35).
            if [[ "$${BINARY}" == "kubelet" ]] && [ -f "./etc/sysconfig/kubelet" ]; then
              echo "Installing /etc/sysconfig/kubelet from RPM"
              cp "./etc/sysconfig/kubelet" "/etc/sysconfig/kubelet"
            fi

            cd /
            rm -rf "$${TEMP_DIR}"
            rm -f "$${RPM_FILE}"
          done

          systemctl restart kubelet

          # Print versions
          echo "kubeadm version: $(kubeadm version -o=short)"
          echo "kubectl version: $(kubectl version --client=true)"
          echo "kubelet version: $(kubelet --version)"
        path: /opt/install-custom-k8s-binaries.sh
        owner: "root:root"
        permissions: "0744"
      preKubeadmCommands:
      - bash -c /tmp/azl3-setup.sh
      - echo '${AZURE_INTERNAL_LB_PRIVATE_IP}   ${CLUSTER_NAME}-${APISERVER_LB_DNS_SUFFIX}.${AZURE_LOCATION}.cloudapp.azure.com' >> /etc/hosts
      - bash -c /opt/install-custom-k8s-binaries.sh
      joinConfiguration:
        nodeRegistration:
          name: '{{ ds.meta_data["local_hostname"] }}'
          kubeletExtraArgs:
            cloud-provider: external
